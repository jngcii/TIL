# 멀티캐스킹의 기본, 스레드(Thread)

###### 2020.01.27

### I. 스레드란?

- 하나의 프로세스 내에서 여러 작업을 병행하는 것

- 메인스레드는 자바 프로그램 시작 시 자동으로 생성되며 main() 메서드를 실행한다.

- main() 메서드의 명령문 실행이 완료되면 메인 스레드는 종료되고 프로그램도 종료된다.

- 여러 사용자가 동시에 요청할 때, 외부 데이터를 처리할때 멀티 스레드를 구현해야한다.

- 멀티스레드는 함께 실행되던 모든 스레드가 모두 종료되어야 프로그램이 종료된다.


<br />

### II. 스레드 활용

#### (1) 구현 및 실행

1. run 메서드

    - 메인 스레드가 아닌 독립적인 스레드에서 동작할 수 있도록 지원하는 객체 : java.lang 패키지의 Thread 클래스

    - Thread 클래스는 실행 시 새로운 스레드를 생성한 후 run() 메서드를 찾아 실행한다.

        ```java
        class PrimeThread extends Thread {
            public void run() {
                // 스레드에서 실행할 명령문
            }
        }
        ```
        ```java
        class PrimeRun implements Runnable {
            public void run() {
                // 스레드에서 실행할 명령문
            }
        }
        ```
        ```java
        Runnable task = () -> {};
        Thread p3 = new Thread(()->{});
        ```
2. start 메서드

    - 스레드에서 처리할 로직을 구현한 run() 메서드는 Thread 클래스의 start() 메서드를 이용해 실행한다.

    - Thread 클래스를 상속하여 run() 메서드를 구현한 경우에는 바로 start() 메서드를 호출할 수 있지만, Runnable 인터페이스를 구현 한 경우에는 Thread 객체를 생성해야 start() 메서드를 호출할 수 있다.

    - Thread 객체를 생성할때는 Runnable 객체를 인자로 줘야한다.

    - Thread를 상속한경우 (`class PrimeThread extends Thread`)

        ```java
        PrimeThread pi = new PrimeThread();
        p1.start();
        ```

    - Runnable을 구현한 경우 (`class PrimeRun implements Runnable`)

        ```java
        PrimeRun p2 = new PrimeRun();
        Thread p1 = new Thread(p2);
        p1.start();
        ```
3. 각 스레드의 실행되는 원리

    - start() 메서드를 호출하여 p1, p2, p3 스레드를 실행하면 각 스레드는 **실행 대기** 상태로 들어간다.

    - 실행 대기 상태는 **JVM의 스케쥴링**에 의해 실행할 수 있는 상태이다.

    - 스케쥴링이란 JVM이 실행되는 스레드를 결정하는 것을 말한다.


#### (2) Thread 클래스

- Thread 클래스는 java.lang 패키지에 정의되어 있고 Runnable 인터페이스를 상속

- 생성자
    - Thread() : 새로운 스레드 생성
    - Thread(Runnable target) : 매개변수로 전달받은 Runnable의 run() 메서드를 실행하는 스레드 생성
    - Thread(Runnable target, String name) : target의 run() 메서드를 실행하며 이름을 지정한 새로운 스레드 생성
    - Thread(String name) : 이름을 지정한 스레드 생성

- 필드
    - public static final int MAX_PRIORITY = 10;
    - public static final int MIN_PRIORITY = 1;
    - public static final int NORM_PRIORITY = 5;

- 메서드
    - String getName()
    - int getPriority()
    - boolean isAlive()
    - void joi()
    - void run()
    - static void sleep(long millis)
    - void start()

- 스레드클래스 예제

    ```java
    public class Test01 {
        public static void main(String[] args) {
            Food work1 = new Food();
            Phone work2 = new Phone();

            work1.start();
            work2.start();
            
            for(int i=1; i<=1000; i++) {
                System.out.println("TV 보기 : " + i);
            }
        }
    }

    class Food extends Thread {
        public void run() {
            for(int i=1; i<=1000; i++) {
                System.out.println("음식 먹기 : " + i);
            }
        }
    }

    class Phone extends Thread {
        public void run() {
            for(int i=1; i<=1000; i++) {
                System.out.println("전화 받기 : " + i);
            }
        }
    }
    ```

- 러너블인터페이스 예제

    ```java
    public class test02 {
        public static void main(String[] args) {
            Thread t1 = new Thread(new Movie());

            // Thread 인자로 Runnable인터페이스를 구현한 객체를 지정해야한다.
            // Runnable 인터페이스는 run이라는 추상메서드 하나밖에 없기 때문에
            // 람다를 통해 구현 가능 (Runnable은 함수형 인터페이스)
            // Runnable을 익명으로 구현해서 보낸것과 같은 원리...
            Thread t2 = new Thread(()-> {
                for(int i=1; i<=1000; i++) {
                    System.out.println("전화받기 : " + i);
                }
            });

            t1.start();
            t2.start();
            for(int i=1; i<= 1000; i++) {
                System.out.println("TV 보기 : " + i);
            }
        }
    }

    class Movie implements Runnable {
        @Override
        public void run() {
            for(int i=0; i <= 1000; i++) {
                System.out.println("음식 먹기 : " + i);
            }
        }
    }
    ```

<br />

### III. 동기화

>좌석 예매에 먼저 접근한 사람이 작업을 완료할 때까지 다른 사람은 접근하지 못하도록 처리하는 것
>
>하나의 자원에 여러 스레드가 동시에 접근하여 사용할 때 발생할 수 있는 오류를 방지하기 위한 작업

#### (1) 동기화 처리

- 프로그램 구현 시 동기화는 블록이나 메서드 단위로 작업할 수 있다.

- 블록이나 메서드를 선언할 때, `synchronized` 키워드만 선언하면 된다.

    - 블록 동기화 : synchronized(객체명) { ... }

        ```java
        public void run() {
            synchronized (account) {
                // 실행 내용
            }
        }
        // synchronized 블록의 account 객체에 대한 동기화를 처리한다.
        // account 객체에 접근할때 동기화 사용한다.!!!!!!!!!!!!!!!!!!!! 중요중요!!!!
        ```

    - 메서드 동기화 : synchronized 메서드명() { ... }

        ```java
        public synchronized void draw(long amount) {
            balance -= amount;
        }
        // draw 기능을 사용할때 동기화 사용한다!!!!!!!!!!!!!!!!!!! 중요오오!!!!!!!!!!!!
        ```