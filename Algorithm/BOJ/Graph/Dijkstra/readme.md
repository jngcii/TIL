# 다익스트라(Dijkstra)

###### 2020.02.26

- 최단거리 알고리즘
- 시간복잡도 : O(V^2) or O(ElogE)

### 필요한 것

- dist[i] : 시작 -> i의 최단 거리
- check[i] : i를 검사했으면 true, 아니면 false

### 방법 

- dist가 작은 것부터 검사하면서 거기에 연결되어 있는 간선을 모두 검사하는 알고리즘
- 간선을 (from, to, cost)라 했을 때, dist[to]>dist[from]+cost면 갱신해준다.

1. 처음에 1번에서 시작한다.
2. 1번은 1번으로 가는 비용이 0이므로 0으로 설정하고 이미 시작하는 곳이 1이므로 check[1]또한 True로 변경한다.
3. 1에 이어진 간선들을 검사하고 dist를 갱신한다.
4. 아직 간 상태는 아니므로 check[1]만 True이다.
5. 다음은 check가 False인 것들 중 dist가 가장 작은 것을 체크하고 3으로 돌아간다.

### 역추적

- 최단거리가 나온 경로를 뽑아야 할 때
- dijkstra, dfs, dp 등 대부분 알고리즘의 역추적은 왜 바꼈는지 기록하면 된다.
- x -> y 일때, dist[y]의 값이 x에 의해 바뀌었으면 기록
  
  ```python
  if dist[y] > dist[x] + a[x][i].cost:

      dist[y] = dist[x] + a[x][i].cost

      v[y] = x
  ```
  > 계속 왜 바꼈는지를 따라가면 시작점이 나올 것이다.

### 시간 줄이기

- 검사하지 않은 정점 중에서 dist의 값이 가장 작은 정점 v를 선택한다.
- 보통 최소나 최대를 구하는데
- 구하는 방법은 우선순위 큐 혹은 세그먼트 트리(구간을 정할때)를 사용한다.
- i의 dist와 i(실제 저장번호)의 쌍을 힙에 저장
- 제일 처음에는 (0, 1) 이 저장되어 있다.
- 원래는 모든 정점을 보면서 1이 최소다! 해서 뽑았었지만 이제는 우선순위 큐를 그냥 pop해서 뽑는다.