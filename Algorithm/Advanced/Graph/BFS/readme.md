# BFS

###### 2020.03.03

- BFS를 사용하여 풀수 있는 문제의 조건
  - 최소를 구하는 문제
  - 가중치가 1
  - 정점, 간선이 차이가 별로 없고, 두개를 더해 1억이 안돼야 한다.
  - 위 세가지를 모두 충족할시 BFS로 풀이 가능

### [0과 1](8111.0과1.py)
- `1011`을 3으로 나누면 나머지 0
  - `10110`을 3으로 나누면 나머지 0
  - `10111`을 3으로 나누면 나머지 1
- `111`을 3으로 나눠도 나머지 0
  - `1110`을 3으로 나누면 나머지 0
  - `1111`을 3으로 나누면 나머지 1
- `___(a)___ % N = R`이라 할 때, 모든 R에 대해서 길이가 가장 짧은 것을 구하자
- 한번 N으로 나눈 나머지가 R인 (a)가 나오면, 0이나 1을 붙여봤자 같은게 나온다. 
- 그 때, R이 0이 되는것을 찾자.
- 0과 1로 이루어진 수 중에서 N으로 나눈 나머지는 총 N개 존재한다. (0 ~ N-1)
- 3가지의 배열 필요 (-1로 초기화)
  - `fr` : y라는 숫자가 되기 위해 그 전에 어떤거에서 y가 되었는지를 기록(x를 기록) - `fr[y] = x`
  - `how` : x에서 y를 어떻게 만들었는가? - 0이나 1 중 하나
  - `dist` : dist\[i]는 나머지 i를 만들 수 있는 가장 짧은 숫자
- 제일 처음에 q에 `1%n`을 넣는다.
  - N이 1부터 시작하기 때문에 만약 N이 1이라면 답을 못구하거나 이상한 값을 구하게 되게 때문이다.


### [숨바꼭질 5](17071.숨바꼭질5.py)
- 원래 BFS의 원칙 : 같은 정점을 두번 이상 방문하지 않는다.
- 하지만 이 문제는 같은 정점을 두번 이상 방문한다.
- i초 후의 동생의 위치는 정해져 있기 때문에 그 정보를 이용해서 동생이 이동할때마다 BFS를 초기화한다.